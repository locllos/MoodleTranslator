# Оптимизация хеш-таблицы
Суть данного проекта заключалась в оптимизации такой структуры данных, как хеш-таблица. Здесь хеш-таблица использовалась для поиска переводов слов. Также был реализован "дословный переводчик", суть которого заключалась отображении перевода слова с английского на русский, при наведении на его английский вариант.

Пример:
![](https://i.imgur.com/IosgJ2t.png)


## Формальности окончены - вперёд оптимизировать
### Мне не приходят на ум алгоритмы, но хочу, чтобы программа работала быстрее
Я написал свой дословный переводчик, но вот незадача, он слишком медленный, при этом алгоритма умнее с более хорошей асимпотикой не придумаешь, тогда на помощь мне приходят ***ассемблерные вставочки!*** 
### С чего начать
Для начала определим, какая из функций работает медленее всего. С этой целью мы воспользуемся ***valgrind***, а если быть более точным, то инструментов valgrind'a - ***callgrind***. 

#### Но перед этим...
Но перед этим посмотрим, сколько времени работает программа без оптимзаций.
Для тестирования мы много (порядка 2 миллионов) раз проводили запрос типа Find для элементов хеш-таблицы.

Время: ***6.93 секунд***

### Запустили - молодцы
Итак, вот какие функции работают дольше всего:

![](https://i.imgur.com/5LpSiMd.png)

*уточним: HolyPoly функция подсчёта полиномиального хеша

### Какие выводы можно сделать с картиночки
Вперёд оптимизировать HolyPoly и strcasecmp!

### Пора приступать к оптимизации
#### Начнём с функции HolyPoly
Напишем ассемблерный аналог HolyPoly и слинкуем её с нашей прогой

![](https://i.imgur.com/HVZp55T.png)


#### Ну и каков результат

Результат не может не радовать, ведь благодаря тому, что мы написали функцию подсчёта хеша на ассемблере, время работы нашей функции уменьшилось: стало ***6.5 сек***
При этом доля работы этой функции значительно уменьшилась, вместо почти 25% она стала занимать лишь 11.6%

![](https://i.imgur.com/d9cueHJ.png)



### Пойдём оптимизировать strcasecmp

#### Ну и чего мы тут понаписали
А мы решили взять и переписать строки на avx2. И благодаря этому у нас вместо кучи сравнений по одному символы, всё будем происходить за один раз.

![](https://i.imgur.com/0yOm3Sh.png)


#### Ну и что? Ускорило что ли
Да, ускорило.
При этом достаточно значительно: теперь тест проходит за: ***5.36 секунд***


### До и после
Подытожим и посмотрим на сколько быстрее стало выполняться суммарно
* До оптимизации: ~6.93c
* После оптимизации: ~5.36c

Общий прирост: **24%**

### Итог
Добавим для сравнения нашу неоптимизированную программу, скомпилированную с флагом -О3. Она отработала за 6.3 секунды, что медленее нашей оптимизации, использующую AVX инструкции. Наша реализация быстрее -О3 на 15%.

Покажем результаты на графике.
* **Not Optimized** - изначальная версия программы
* **Asm** - версия, где мы переписали функцию подсчёта хеша в ассемблер
* **-O3** - версия, скомилированная с флагом О3
* **Asm + Avx** - версия, c переписанной на ассемблер функцией и с добавлением AVX инструкций
![](https://i.imgur.com/hcMS8tk.png)

Для наглядности отобразим график прироста производительности, то есть на сколько у нас увеличивалась скорость работы программы:
* "Not optimize -> asm" - прирост при переходе от неоптимизированной к версии, с ассебмлерной вставкой
* "asm -> asm + avx" - прирост при добавлении AVX инструкций
* "-O3 -> asm + avx" - прирост относительно -O3
![](https://i.imgur.com/eNpZgDS.png)

Как мы видим, даже -О3 не смог обогнать наши AVX'ики!

### Стоит ли продолжать
Ну, давайте взглянем на наш топ самых долгоработающих функций:

![](https://i.imgur.com/IqsgDWF.png)


### О БОГИ, О, НЕТ, СМОТРИТЕ, ВОТ ЖЕ ДВЕ ФУНКЦИИ - ОНИ ОЧЕНЬ ДОЛГО РАБОТАЮТ!
#### Так, давайте по порядку. 
Насколько мы помним, функцию подсчёта хеша мы переделали с помощью ассемблера, мы провели замеры времени, стало работать на самом деле быстрее, то, что она в топе говорит нам лишь о том, что она очень часто вызывается (действительно, около 18 млн. раз - очень много). 
#### Ну, а что насчёт findHashTable тогда
Хорошо, давайте, ради эксперимента попытаемся её улучшить. Перепишем цикл for в виде ассемблерной вставки в код программы:

![](https://i.imgur.com/MIJoM8U.png)

#### Успокаивающий скриншот из профайлера
![](https://i.imgur.com/6bejf8j.png)

(Бурча под нос) Ну, да, да, доля работы этой функции заметно уменьшилась...
А давайте теперь взглянем на время!

Итак, замерив время, мы получили результат в **5.24 секунды**, что дало прироста сущие ***2.3%***! Возникает вопрос: ***А стоило ли?***. Я, как человек, писавший эту ассемблерную вставку, скажу, что можно было остановиться на оптимизации с AVX-инструкциями, потому что прирост, который мы получили при замене цикла for на ассемблерную вставку много меньше прироста производительности при подключении AVX-инструкций. Для наглядности покажем сравнительный график приростов:

* "Asm+Avx" - версия, с AVX-инструкцией и одной польностью переписанной на ассемблер функцией.
* "Asm+Avx+inlineAsm" - версия, с теми же, что были сказаны выше, оптимизациями с добавлением ассемблерной вставки
![](https://i.imgur.com/9PtkwqM.png)
Из графика наглядно видно, что этот незначительный прирост не стоил свеч и труда бедного программиста.

#### Хорошо, вы нас убедили, можете остановиться. Выпишем вам премию.

# Итог всех итогов
Проведя дорогостоящие исследования и измерения, можно подытожить и уверенно сказать: программа ускорена на 26% процентов.